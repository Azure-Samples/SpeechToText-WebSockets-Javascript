{"version":3,"sources":["src/common.browser/OpusRecorder.ts"],"names":[],"mappings":"AAMA,MAAM;IAIF,YAAY,OAAqD;QAI1D,WAAM,GAAG,CAAC,OAAqB,EAAE,WAAwB,EAAE,YAAiC;YAC/F,MAAM,aAAa,GAAQ,IAAI,aAAa,CAAC,WAAW,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;YACrF,MAAM,SAAS,GAAG,GAAG,CAAC;YACtB,aAAa,CAAC,eAAe,GAAG,CAAC,kBAAuB;gBACpD,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;oBACf,MAAM,MAAM,GAAG,IAAI,UAAU,EAAE,CAAC;oBAChC,MAAM,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;oBAClD,MAAM,CAAC,SAAS,GAAG,CAAC,KAAoB;wBACpC,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;oBACtC,CAAC,CAAC;gBACN,CAAC;YACL,CAAC,CAAC;YAEF,IAAI,CAAC,cAAc,GAAG;gBAClB,QAAQ,EAAE,aAAa;gBACvB,MAAM,EAAE,WAAW;aACtB,CAAC;YACF,aAAa,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACnC,CAAC,CAAA;QAEM,0BAAqB,GAAG,CAAC,OAAqB;YACjD,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC;gBACpD,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;YACxC,CAAC;YACD,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC,KAAU,KAAK,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;QACjF,CAAC,CAAA;QA5BG,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC;IACxC,CAAC;CA4BJ","file":"OpusRecorder.js","sourcesContent":["import { Stream } from \"../common/Exports\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\n// getting around the build error for MediaRecorder as Typescript does not have a definition for this one.\r\ndeclare var MediaRecorder: any;\r\n\r\nexport class OpusRecorder implements IRecorder {\r\n    private mediaResources: IMediaResources;\r\n    private mediaRecorderOptions: any;\r\n\r\n    constructor(options?: { mimeType: string, bitsPerSecond: number }) {\r\n        this.mediaRecorderOptions = options;\r\n    }\r\n\r\n    public Record = (context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void => {\r\n        const mediaRecorder: any = new MediaRecorder(mediaStream, this.mediaRecorderOptions);\r\n        const timeslice = 100; // this is in ms - 100 ensures that the chunk doesn't exceed the max size of chunk allowed in WS connection\r\n        mediaRecorder.ondataavailable = (dataAvailableEvent: any) => {\r\n            if (outputStream) {\r\n                const reader = new FileReader();\r\n                reader.readAsArrayBuffer(dataAvailableEvent.data);\r\n                reader.onloadend = (event: ProgressEvent) => {\r\n                    outputStream.Write(reader.result);\r\n                };\r\n            }\r\n        };\r\n\r\n        this.mediaResources = {\r\n            recorder: mediaRecorder,\r\n            stream: mediaStream,\r\n        };\r\n        mediaRecorder.start(timeslice);\r\n    }\r\n\r\n    public ReleaseMediaResources = (context: AudioContext): void => {\r\n        if (this.mediaResources.recorder.state !== \"inactive\") {\r\n            this.mediaResources.recorder.stop();\r\n        }\r\n        this.mediaResources.stream.getTracks().forEach((track: any) => track.stop());\r\n    }\r\n}\r\n\r\ninterface IMediaResources {\r\n    stream: MediaStream;\r\n    recorder: any;\r\n}\r\n\r\n/* Declaring this inline to avoid compiler warnings\r\ndeclare class MediaRecorder {\r\n    constructor(mediaStream: MediaStream, options: any);\r\n\r\n    public state: string;\r\n\r\n    public ondataavailable(dataAvailableEvent: any): void;\r\n    public stop(): void;\r\n}*/\r\n"]}