{"version":3,"sources":["src/common/Stream.ts"],"names":[],"mappings":"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","file":"Stream.js","sourcesContent":["import { InvalidOperationError } from \"./Error\";\r\nimport { CreateNoDashGuid } from \"./Guid\";\r\nimport { IStringDictionary } from \"./IDictionary\";\r\nimport { Promise } from \"./Promise\";\r\nimport { Queue } from \"./Queue\";\r\nimport { IStreamChunk } from \"./Stream\";\r\n\r\nexport interface IStreamChunk<TBuffer> {\r\n    IsEnd: boolean;\r\n    Buffer: TBuffer;\r\n}\r\n\r\nexport class Stream<TBuffer> {\r\n    private id: string;\r\n    private readerIdCounter: number = 1;\r\n    private streambuffer: Array<IStreamChunk<TBuffer>>;\r\n    private isEnded: boolean = false;\r\n    private readerQueues: IStringDictionary<Queue<IStreamChunk<TBuffer>>>;\r\n\r\n    public constructor(streamId?: string) {\r\n        this.id = streamId ? streamId : CreateNoDashGuid();\r\n        this.streambuffer = [];\r\n        this.readerQueues = {};\r\n    }\r\n\r\n    public get IsClosed(): boolean {\r\n        return this.isEnded;\r\n    }\r\n\r\n    public get Id(): string {\r\n        return this.id;\r\n    }\r\n\r\n    public Write = (buffer: TBuffer): void => {\r\n        this.ThrowIfClosed();\r\n        this.WriteStreamChunk({\r\n            Buffer: buffer,\r\n            IsEnd: false,\r\n        });\r\n    }\r\n\r\n    public GetReader = (): StreamReader<TBuffer> => {\r\n        const readerId = this.readerIdCounter;\r\n        this.readerIdCounter++;\r\n        const readerQueue = new Queue<IStreamChunk<TBuffer>>();\r\n        const currentLength = this.streambuffer.length;\r\n        this.readerQueues[readerId] = readerQueue;\r\n        for (let i = 0; i < currentLength; i++) {\r\n            readerQueue.Enqueue(this.streambuffer[i]);\r\n        }\r\n        return new StreamReader(\r\n            this.id,\r\n            readerQueue,\r\n            () => {\r\n                delete this.readerQueues[readerId];\r\n            });\r\n    }\r\n\r\n    public Close = (): void => {\r\n        if (!this.isEnded) {\r\n            this.WriteStreamChunk({\r\n                Buffer: null,\r\n                IsEnd: true,\r\n            });\r\n            this.isEnded = true;\r\n        }\r\n    }\r\n\r\n    private WriteStreamChunk = (streamChunk: IStreamChunk<TBuffer>): void => {\r\n        this.ThrowIfClosed();\r\n        this.streambuffer.push(streamChunk);\r\n        for (const readerId in this.readerQueues) {\r\n            if (!this.readerQueues[readerId].IsDisposed()) {\r\n                try {\r\n                    this.readerQueues[readerId].Enqueue(streamChunk);\r\n                } catch (e) {\r\n                    // Do nothing\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private ThrowIfClosed = (): void => {\r\n        if (this.isEnded) {\r\n            throw new InvalidOperationError(\"Stream closed\");\r\n        }\r\n    }\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nexport class StreamReader<TBuffer> {\r\n    private readerQueue: Queue<IStreamChunk<TBuffer>>;\r\n    private onClose: () => void;\r\n    private isClosed: boolean = false;\r\n    private streamId: string;\r\n\r\n    public constructor(streamId: string, readerQueue: Queue<IStreamChunk<TBuffer>>, onClose: () => void) {\r\n        this.readerQueue = readerQueue;\r\n        this.onClose = onClose;\r\n        this.streamId = streamId;\r\n    }\r\n\r\n    public get IsClosed(): boolean {\r\n        return this.isClosed;\r\n    }\r\n\r\n    public get StreamId(): string {\r\n        return this.streamId;\r\n    }\r\n\r\n    public Read = (): Promise<IStreamChunk<TBuffer>> => {\r\n        if (this.IsClosed) {\r\n            throw new InvalidOperationError(\"StreamReader closed\");\r\n        }\r\n\r\n        return this.readerQueue\r\n            .Dequeue()\r\n            .OnSuccessContinueWith((streamChunk: IStreamChunk<TBuffer>) => {\r\n                if (streamChunk.IsEnd) {\r\n                    this.readerQueue.Dispose(\"End of stream reached\");\r\n                }\r\n\r\n                return streamChunk;\r\n            });\r\n    }\r\n\r\n    public Close = (): void => {\r\n        if (!this.isClosed) {\r\n            this.isClosed = true;\r\n            this.readerQueue.Dispose(\"StreamReader closed\");\r\n            this.onClose();\r\n        }\r\n    }\r\n}\r\n"]}