import { IDetachable } from "./IDetachable";
import { IDisposable } from "./IDisposable";
export interface IList<TItem> extends IDisposable {
    Get(itemIndex: number): TItem;
    First(): TItem;
    Last(): TItem;
    Add(item: TItem): void;
    InsertAt(index: number, item: TItem): void;
    RemoveFirst(): TItem;
    RemoveLast(): TItem;
    RemoveAt(index: number): TItem;
    Remove(index: number, count: number): TItem[];
    Clear(): void;
    Length(): number;
    OnAdded(addedCallback: () => void): IDetachable;
    OnRemoved(removedCallback: () => void): IDetachable;
    OnDisposed(disposedCallback: () => void): IDetachable;
    Join(seperator?: string): string;
    ToArray(): TItem[];
    Any(callback?: (item: TItem, index: number) => boolean): boolean;
    All(callback: (item: TItem) => boolean): boolean;
    ForEach(callback: (item: TItem, index: number) => void): void;
    Select<T2>(callback: (item: TItem, index: number) => T2): List<T2>;
    Where(callback: (item: TItem, index: number) => boolean): List<TItem>;
    OrderBy(compareFn: (a: TItem, b: TItem) => number): List<TItem>;
    OrderByDesc(compareFn: (a: TItem, b: TItem) => number): List<TItem>;
    Clone(): List<TItem>;
    Concat(list: List<TItem>): List<TItem>;
    ConcatArray(array: TItem[]): List<TItem>;
}
export declare class List<TItem> implements IList<TItem> {
    private list;
    private subscriptionIdCounter;
    private addSubscriptions;
    private removeSubscriptions;
    private disposedSubscriptions;
    private disposeReason;
    constructor(list?: TItem[]);
    Get: (itemIndex: number) => TItem;
    First: () => TItem;
    Last: () => TItem;
    Add: (item: TItem) => void;
    InsertAt: (index: number, item: TItem) => void;
    RemoveFirst: () => TItem;
    RemoveLast: () => TItem;
    RemoveAt: (index: number) => TItem;
    Remove: (index: number, count: number) => TItem[];
    Clear: () => void;
    Length: () => number;
    OnAdded: (addedCallback: () => void) => IDetachable;
    OnRemoved: (removedCallback: () => void) => IDetachable;
    OnDisposed: (disposedCallback: () => void) => IDetachable;
    Join: (seperator?: string) => string;
    ToArray: () => TItem[];
    Any: (callback?: (item: TItem, index: number) => boolean) => boolean;
    All: (callback: (item: TItem) => boolean) => boolean;
    ForEach: (callback: (item: TItem, index: number) => void) => void;
    Select: <T2>(callback: (item: TItem, index: number) => T2) => List<T2>;
    Where: (callback: (item: TItem, index: number) => boolean) => List<TItem>;
    OrderBy: (compareFn: (a: TItem, b: TItem) => number) => List<TItem>;
    OrderByDesc: (compareFn: (a: TItem, b: TItem) => number) => List<TItem>;
    Clone: () => List<TItem>;
    Concat: (list: List<TItem>) => List<TItem>;
    ConcatArray: (array: TItem[]) => List<TItem>;
    IsDisposed: () => boolean;
    Dispose: (reason?: string) => void;
    private ThrowIfDisposed;
    private TriggerSubscriptions;
}
