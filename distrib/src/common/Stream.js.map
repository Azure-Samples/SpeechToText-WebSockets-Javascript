{"version":3,"sources":["../src/common/Stream.ts"],"names":[],"mappings":"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","file":"Stream.js","sourcesContent":["import { InvalidOperationError } from \"./Error\";\r\nimport { CreateNoDashGuid } from \"./Guid\";\r\nimport { IStringDictionary } from \"./IDictionary\";\r\nimport { Promise } from \"./Promise\";\r\nimport { Queue } from \"./Queue\";\r\nimport { IStreamChunk } from \"./Stream\";\r\n\r\nexport interface IStreamChunk<TBuffer> {\r\n    IsEnd: boolean;\r\n    Buffer: TBuffer;\r\n}\r\n\r\nexport class Stream<TBuffer> {\r\n    private id: string;\r\n    private readerIdCounter: number = 1;\r\n    private streambuffer: Array<IStreamChunk<TBuffer>>;\r\n    private isEnded: boolean = false;\r\n    private readerQueues: IStringDictionary<Queue<IStreamChunk<TBuffer>>>;\r\n\r\n    public constructor(streamId?: string) {\r\n        this.id = streamId ? streamId : CreateNoDashGuid();\r\n        this.streambuffer = [];\r\n        this.readerQueues = {};\r\n    }\r\n\r\n    public get IsClosed(): boolean {\r\n        return this.isEnded;\r\n    }\r\n\r\n    public get Id(): string {\r\n        return this.id;\r\n    }\r\n\r\n    public Write = (buffer: TBuffer): void => {\r\n        this.ThrowIfClosed();\r\n        this.WriteStreamChunk({\r\n            Buffer: buffer,\r\n            IsEnd: false,\r\n        });\r\n    }\r\n\r\n    public GetReader = (): StreamReader<TBuffer> => {\r\n        const readerId = this.readerIdCounter;\r\n        this.readerIdCounter++;\r\n        const readerQueue = new Queue<IStreamChunk<TBuffer>>();\r\n        const currentLength = this.streambuffer.length;\r\n        this.readerQueues[readerId] = readerQueue;\r\n        for (let i = 0; i < currentLength; i++) {\r\n            readerQueue.Enqueue(this.streambuffer[i]);\r\n        }\r\n        return new StreamReader(\r\n            this.id,\r\n            readerQueue,\r\n            () => {\r\n                delete this.readerQueues[readerId];\r\n            });\r\n    }\r\n\r\n    public Close = (): void => {\r\n        if (!this.isEnded) {\r\n            this.WriteStreamChunk({\r\n                Buffer: null,\r\n                IsEnd: true,\r\n            });\r\n            this.isEnded = true;\r\n        }\r\n    }\r\n\r\n    private WriteStreamChunk = (streamChunk: IStreamChunk<TBuffer>): void => {\r\n        this.ThrowIfClosed();\r\n        this.streambuffer.push(streamChunk);\r\n        for (const readerId in this.readerQueues) {\r\n            if (!this.readerQueues[readerId].IsDisposed()) {\r\n                try {\r\n                    this.readerQueues[readerId].Enqueue(streamChunk);\r\n                } catch (e) {\r\n                    // Do nothing\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private ThrowIfClosed = (): void => {\r\n        if (this.isEnded) {\r\n            throw new InvalidOperationError(\"Stream closed\");\r\n        }\r\n    }\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nexport class StreamReader<TBuffer> {\r\n    private readerQueue: Queue<IStreamChunk<TBuffer>>;\r\n    private onClose: () => void;\r\n    private isClosed: boolean = false;\r\n    private streamId: string;\r\n\r\n    public constructor(streamId: string, readerQueue: Queue<IStreamChunk<TBuffer>>, onClose: () => void) {\r\n        this.readerQueue = readerQueue;\r\n        this.onClose = onClose;\r\n        this.streamId = streamId;\r\n    }\r\n\r\n    public get IsClosed(): boolean {\r\n        return this.isClosed;\r\n    }\r\n\r\n    public get StreamId(): string {\r\n        return this.streamId;\r\n    }\r\n\r\n    public Read = (): Promise<IStreamChunk<TBuffer>> => {\r\n        if (this.IsClosed) {\r\n            throw new InvalidOperationError(\"StreamReader closed\");\r\n        }\r\n\r\n        return this.readerQueue\r\n            .Dequeue()\r\n            .OnSuccessContinueWith((streamChunk: IStreamChunk<TBuffer>) => {\r\n                if (streamChunk.IsEnd) {\r\n                    this.readerQueue.Dispose(\"End of stream reached\");\r\n                }\r\n\r\n                return streamChunk;\r\n            });\r\n    }\r\n\r\n    public Close = (): void => {\r\n        if (!this.isClosed) {\r\n            this.isClosed = true;\r\n            this.readerQueue.Dispose(\"StreamReader closed\");\r\n            this.onClose();\r\n        }\r\n    }\r\n}\r\n"]}