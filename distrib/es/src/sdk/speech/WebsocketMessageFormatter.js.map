{"version":3,"sources":["src/sdk/speech/WebsocketMessageFormatter.ts"],"names":[],"mappings":"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","file":"WebsocketMessageFormatter.js","sourcesContent":["import {\r\n    ConnectionMessage,\r\n    Deferred,\r\n    IStringDictionary,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    Promise,\r\n    RawWebsocketMessage,\r\n} from \"../../common/Exports\";\r\n\r\nconst CRLF: string = \"\\r\\n\";\r\n\r\nexport class WebsocketMessageFormatter implements IWebsocketMessageFormatter {\r\n\r\n    public ToConnectionMessage = (message: RawWebsocketMessage): Promise<ConnectionMessage> => {\r\n        const deferral = new Deferred<ConnectionMessage>();\r\n\r\n        try {\r\n            if (message.MessageType === MessageType.Text) {\r\n                const textMessage: string = message.TextContent;\r\n                let headers: IStringDictionary<string> = {};\r\n                let body: string = null;\r\n\r\n                if (textMessage) {\r\n                    const headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\r\n                    if (headerBodySplit && headerBodySplit.length > 0) {\r\n                        headers = this.ParseHeaders(headerBodySplit[0]);\r\n                        if (headerBodySplit.length > 1) {\r\n                            body = headerBodySplit[1];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                deferral.Resolve(new ConnectionMessage(message.MessageType, body, headers, message.Id));\r\n            } else if (message.MessageType === MessageType.Binary) {\r\n                const binaryMessage: ArrayBuffer = message.BinaryContent;\r\n                let headers: IStringDictionary<string> = {};\r\n                let body: ArrayBuffer = null;\r\n\r\n                if (!binaryMessage || binaryMessage.byteLength < 2) {\r\n                    throw new Error(\"Invalid binary message format. Header length missing.\");\r\n                }\r\n\r\n                const dataView = new DataView(binaryMessage);\r\n                const headerLength = dataView.getInt16(0);\r\n\r\n                if (binaryMessage.byteLength < headerLength + 2) {\r\n                    throw new Error(\"Invalid binary message format. Header content missing.\");\r\n                }\r\n\r\n                let headersString = \"\";\r\n                for (let i = 0; i < headerLength; i++) {\r\n                    headersString += String.fromCharCode((dataView).getInt8(i + 2));\r\n                }\r\n\r\n                headers = this.ParseHeaders(headersString);\r\n\r\n                if (binaryMessage.byteLength > headerLength + 2) {\r\n                    body = binaryMessage.slice(2 + headerLength);\r\n                }\r\n\r\n                deferral.Resolve(new ConnectionMessage(message.MessageType, body, headers, message.Id));\r\n            }\r\n        } catch (e) {\r\n            deferral.Reject(`Error formatting the message. Error: ${e}`);\r\n        }\r\n\r\n        return deferral.Promise();\r\n    }\r\n\r\n    public FromConnectionMessage = (message: ConnectionMessage): Promise<RawWebsocketMessage> => {\r\n        const deferral = new Deferred<RawWebsocketMessage>();\r\n\r\n        try {\r\n            if (message.MessageType === MessageType.Text) {\r\n                const payload = `${this.MakeHeaders(message)}${CRLF}${message.TextBody ? message.TextBody : \"\"}`;\r\n\r\n                deferral.Resolve(new RawWebsocketMessage(MessageType.Text, payload, message.Id));\r\n\r\n            } else if (message.MessageType === MessageType.Binary) {\r\n                const headersString = this.MakeHeaders(message);\r\n                const content = message.BinaryBody;\r\n\r\n                const fr = new FileReader();\r\n\r\n                fr.onload = () => {\r\n                    const headerInt8Array = new Int8Array(fr.result);\r\n\r\n                    const payload = new ArrayBuffer(2 + headerInt8Array.byteLength + (content ? content.byteLength : 0));\r\n                    const dataView = new DataView(payload);\r\n\r\n                    dataView.setInt16(0, headerInt8Array.length);\r\n\r\n                    for (let i = 0; i < headerInt8Array.byteLength; i++) {\r\n                        dataView.setInt8(2 + i, headerInt8Array[i]);\r\n                    }\r\n\r\n                    if (content) {\r\n                        const bodyInt8Array = new Int8Array(content);\r\n                        for (let i = 0; i < bodyInt8Array.byteLength; i++) {\r\n                            dataView.setInt8(2 + headerInt8Array.byteLength + i, bodyInt8Array[i]);\r\n                        }\r\n                    }\r\n\r\n                    deferral.Resolve(new RawWebsocketMessage(MessageType.Binary, payload, message.Id));\r\n                };\r\n\r\n                fr.onerror = () => {\r\n                    deferral.Reject(\"failed to load headers into file reader\");\r\n                };\r\n\r\n                fr.readAsArrayBuffer(new Blob([headersString]));\r\n            }\r\n        } catch (e) {\r\n            deferral.Reject(`Error formatting the message. ${e}`);\r\n        }\r\n\r\n        return deferral.Promise();\r\n    }\r\n\r\n    private MakeHeaders = (message: ConnectionMessage): string => {\r\n        let headersString: string = \"\";\r\n\r\n        if (message.Headers) {\r\n            for (const header in message.Headers) {\r\n                if (header) {\r\n                    headersString += `${header}: ${message.Headers[header]}${CRLF}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return headersString;\r\n    }\r\n\r\n    private ParseHeaders = (headersString: string): IStringDictionary<string> => {\r\n        const headers: IStringDictionary<string> = {};\r\n\r\n        if (headersString) {\r\n            const headerMatches = headersString.match(/[^\\r\\n]+/g);\r\n            if (headers) {\r\n                for (const header of headerMatches) {\r\n                    if (header) {\r\n                        const separatorIndex = header.indexOf(\":\");\r\n                        const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\r\n                        const headerValue =\r\n                            separatorIndex > 0 && header.length > (separatorIndex + 1) ?\r\n                                header.substr(separatorIndex + 1).trim() :\r\n                                \"\";\r\n\r\n                        headers[headerName] = headerValue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return headers;\r\n    }\r\n}\r\n"]}