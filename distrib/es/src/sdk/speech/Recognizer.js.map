{"version":3,"sources":["src/sdk/speech/Recognizer.ts"],"names":[],"mappings":"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","file":"Recognizer.js","sourcesContent":["import {\r\n    ArgumentNullError,\r\n    ConnectionMessage,\r\n    ConnectionOpenResponse,\r\n    ConnectionState,\r\n    CreateNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    IDetachable,\r\n    IEventSource,\r\n    IStreamChunk,\r\n    MessageType,\r\n    PlatformEvent,\r\n    Promise,\r\n    PromiseHelper,\r\n    PromiseResult,\r\n} from \"../../common/Exports\";\r\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory\";\r\nimport {\r\n    ConnectingToServiceEvent,\r\n    ListeningStartedEvent,\r\n    RecognitionCompletionStatus,\r\n    RecognitionEndedEvent,\r\n    RecognitionStartedEvent,\r\n    RecognitionTriggeredEvent,\r\n    SpeechDetailedPhraseEvent,\r\n    SpeechEndDetectedEvent,\r\n    SpeechFragmentEvent,\r\n    SpeechHypothesisEvent,\r\n    SpeechRecognitionEvent,\r\n    SpeechRecognitionResultEvent,\r\n    SpeechSimplePhraseEvent,\r\n    SpeechStartDetectedEvent,\r\n} from \"./RecognitionEvents\";\r\nimport { RecognitionMode, RecognizerConfig, SpeechResultFormat } from \"./RecognizerConfig\";\r\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\nimport {\r\n    IDetailedSpeechPhrase,\r\n    ISimpleSpeechPhrase,\r\n    ISpeechEndDetectedResult,\r\n    ISpeechFragment,\r\n    ISpeechStartDetectedResult,\r\n} from \"./SpeechResults\";\r\n\r\nexport class Recognizer {\r\n    private authentication: IAuthentication;\r\n    private connectionFactory: IConnectionFactory;\r\n    private audioSource: IAudioSource;\r\n    private recognizerConfig: RecognizerConfig;\r\n    private speechConfigConnectionId: string;\r\n    private connectionFetchPromise: Promise<IConnection>;\r\n    private connectionId: string;\r\n    private authFetchEventId: string;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig) {\r\n\r\n        if (!authentication) {\r\n            throw new ArgumentNullError(\"authentication\");\r\n        }\r\n\r\n        if (!connectionFactory) {\r\n            throw new ArgumentNullError(\"connectionFactory\");\r\n        }\r\n\r\n        if (!audioSource) {\r\n            throw new ArgumentNullError(\"audioSource\");\r\n        }\r\n\r\n        if (!recognizerConfig) {\r\n            throw new ArgumentNullError(\"recognizerConfig\");\r\n        }\r\n\r\n        this.authentication = authentication;\r\n        this.connectionFactory = connectionFactory;\r\n        this.audioSource = audioSource;\r\n        this.recognizerConfig = recognizerConfig;\r\n    }\r\n\r\n    public get AudioSource(): IAudioSource {\r\n        return this.audioSource;\r\n    }\r\n\r\n    public Recognize = (onEventCallback: (event: SpeechRecognitionEvent) => void, speechContextJson?: string): Promise<boolean> => {\r\n        const requestSession = new RequestSession(this.audioSource.Id(), onEventCallback);\r\n        requestSession.ListenForServiceTelemetry(this.audioSource.Events);\r\n\r\n        return this.audioSource\r\n            .Attach(requestSession.AudioNodeId)\r\n            .ContinueWithPromise<boolean>((result: PromiseResult<IAudioStreamNode>) => {\r\n                if (result.IsError) {\r\n                    requestSession.OnAudioSourceAttachCompleted(null, true, result.Error);\r\n                    throw new Error(result.Error);\r\n                } else {\r\n                    requestSession.OnAudioSourceAttachCompleted(result.Result, false);\r\n                }\r\n\r\n                const audioNode = result.Result;\r\n\r\n                this.FetchConnection(requestSession)\r\n                    .OnSuccessContinueWith((connection: IConnection) => {\r\n                        const messageRetrievalPromise = this.ReceiveMessage(connection, requestSession);\r\n                        const messageSendPromise = this.SendSpeechConfig(requestSession.RequestId, connection, this.recognizerConfig.SpeechConfig.Serialize())\r\n                            .OnSuccessContinueWithPromise((_: boolean) => {\r\n                                return this.SendSpeechContext(requestSession.RequestId, connection, speechContextJson)\r\n                                    .OnSuccessContinueWithPromise((_: boolean) => {\r\n                                        return this.SendAudio(requestSession.RequestId, connection, audioNode, requestSession);\r\n                                    });\r\n                            });\r\n\r\n                        const completionPromise = PromiseHelper.WhenAll([messageRetrievalPromise, messageSendPromise]);\r\n\r\n                        completionPromise.On((r: boolean) => {\r\n                            requestSession.Dispose();\r\n                            this.SendTelemetryData(requestSession.RequestId, connection, requestSession.GetTelemetry());\r\n                        }, (error: string) => {\r\n                            requestSession.Dispose(error);\r\n                            this.SendTelemetryData(requestSession.RequestId, connection, requestSession.GetTelemetry());\r\n                        });\r\n\r\n                        return completionPromise;\r\n                    });\r\n\r\n                return requestSession.CompletionPromise;\r\n            });\r\n    }\r\n\r\n    private FetchConnection = (requestSession: RequestSession, isUnAuthorized: boolean = false): Promise<IConnection> => {\r\n        if (this.connectionFetchPromise) {\r\n            if (this.connectionFetchPromise.Result().IsError\r\n                || this.connectionFetchPromise.Result().Result.State() === ConnectionState.Disconnected) {\r\n                this.connectionId = null;\r\n                this.connectionFetchPromise = null;\r\n                return this.FetchConnection(requestSession);\r\n            } else {\r\n                requestSession.OnPreConnectionStart(this.authFetchEventId, this.connectionId);\r\n                requestSession.OnConnectionEstablishCompleted(200);\r\n                requestSession.ListenForServiceTelemetry(this.connectionFetchPromise.Result().Result.Events);\r\n                return this.connectionFetchPromise;\r\n            }\r\n        }\r\n\r\n        this.authFetchEventId = CreateNoDashGuid();\r\n        this.connectionId = CreateNoDashGuid();\r\n\r\n        requestSession.OnPreConnectionStart(this.authFetchEventId, this.connectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.authentication.FetchOnExpiry(this.authFetchEventId) : this.authentication.Fetch(this.authFetchEventId);\r\n\r\n        this.connectionFetchPromise = authPromise\r\n            .ContinueWithPromise((result: PromiseResult<AuthInfo>) => {\r\n                if (result.IsError) {\r\n                    requestSession.OnAuthCompleted(true, result.Error);\r\n                    throw new Error(result.Error);\r\n                } else {\r\n                    requestSession.OnAuthCompleted(false);\r\n                }\r\n\r\n                const connection = this.connectionFactory.Create(this.recognizerConfig, result.Result, this.connectionId);\r\n                requestSession.ListenForServiceTelemetry(connection.Events);\r\n\r\n                return connection.Open().OnSuccessContinueWithPromise((response: ConnectionOpenResponse) => {\r\n                    if (response.StatusCode === 200) {\r\n                        requestSession.OnConnectionEstablishCompleted(response.StatusCode);\r\n                        return PromiseHelper.FromResult(connection);\r\n                    } else if (response.StatusCode === 403 && !isUnAuthorized) {\r\n                        return this.FetchConnection(requestSession, true);\r\n                    } else {\r\n                        requestSession.OnConnectionEstablishCompleted(response.StatusCode, response.Reason);\r\n                        return PromiseHelper.FromError<IConnection>(`Unable to contact server. StatusCode: ${response.StatusCode}, Reason: ${response.Reason}`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        return this.connectionFetchPromise;\r\n    }\r\n\r\n    private ReceiveMessage = (connection: IConnection, requestSession: RequestSession): Promise<boolean> => {\r\n        return connection\r\n            .Read()\r\n            .OnSuccessContinueWithPromise((message: ConnectionMessage) => {\r\n                const connectionMessage = SpeechConnectionMessage.FromConnectionMessage(message);\r\n                if (connectionMessage.RequestId.toLowerCase() === requestSession.RequestId.toLowerCase()) {\r\n                    switch (connectionMessage.Path.toLowerCase()) {\r\n                        case \"turn.start\":\r\n                            requestSession.OnServiceTurnStartResponse(JSON.parse(connectionMessage.TextBody));\r\n                            break;\r\n                        case \"speech.startDetected\":\r\n                            requestSession.OnServiceSpeechStartDetectedResponse(JSON.parse(connectionMessage.TextBody));\r\n                            break;\r\n                        case \"speech.hypothesis\":\r\n                            requestSession.OnServiceSpeechHypothesisResponse(JSON.parse(connectionMessage.TextBody));\r\n                            break;\r\n                        case \"speech.fragment\":\r\n                            requestSession.OnServiceSpeechFragmentResponse(JSON.parse(connectionMessage.TextBody));\r\n                            break;\r\n                        case \"speech.enddetected\":\r\n                            requestSession.OnServiceSpeechEndDetectedResponse(JSON.parse(connectionMessage.TextBody));\r\n                            break;\r\n                        case \"speech.phrase\":\r\n                            if (this.recognizerConfig.IsContinuousRecognition) {\r\n                                // For continuous recognition telemetry has to be sent for every phrase as per spec.\r\n                                this.SendTelemetryData(requestSession.RequestId, connection, requestSession.GetTelemetry());\r\n                            }\r\n                            if (this.recognizerConfig.Format === SpeechResultFormat.Simple) {\r\n                                requestSession.OnServiceSimpleSpeechPhraseResponse(JSON.parse(connectionMessage.TextBody));\r\n                            } else {\r\n                                requestSession.OnServiceDetailedSpeechPhraseResponse(JSON.parse(connectionMessage.TextBody));\r\n                            }\r\n                            break;\r\n                        case \"turn.end\":\r\n                            requestSession.OnServiceTurnEndResponse();\r\n                            return PromiseHelper.FromResult(true);\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                return this.ReceiveMessage(connection, requestSession);\r\n            });\r\n    }\r\n\r\n    private SendSpeechConfig = (requestId: string, connection: IConnection, speechConfigJson: string) => {\r\n        if (speechConfigJson && this.connectionId !== this.speechConfigConnectionId) {\r\n            this.speechConfigConnectionId = this.connectionId;\r\n            return connection\r\n                .Send(new SpeechConnectionMessage(\r\n                    MessageType.Text,\r\n                    \"speech.config\",\r\n                    requestId,\r\n                    \"application/json\",\r\n                    speechConfigJson));\r\n        }\r\n\r\n        return PromiseHelper.FromResult(true);\r\n    }\r\n\r\n    private SendSpeechContext = (requestId: string, connection: IConnection, speechContextJson: string) => {\r\n        if (speechContextJson) {\r\n            return connection\r\n                .Send(new SpeechConnectionMessage(\r\n                    MessageType.Text,\r\n                    \"speech.context\",\r\n                    requestId,\r\n                    \"application/json\",\r\n                    speechContextJson));\r\n        }\r\n        return PromiseHelper.FromResult(true);\r\n    }\r\n\r\n    private SendTelemetryData = (requestId: string, connection: IConnection, telemetryData: string) => {\r\n        return connection\r\n            .Send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"telemetry\",\r\n                requestId,\r\n                \"application/json\",\r\n                telemetryData));\r\n    }\r\n\r\n    private SendAudio = (\r\n        requestId: string,\r\n        connection: IConnection,\r\n        audioStreamNode: IAudioStreamNode,\r\n        requestSession: RequestSession): Promise<boolean> => {\r\n            // NOTE: Home-baked promises crash ios safari during the invocation\r\n            // of the error callback chain (looks like the recursion is way too deep, and\r\n            // it blows up the stack). The following construct is a stop-gap that does not\r\n            // bubble the error up the callback chain and hence circumvents this problem.\r\n            // TODO: rewrite with ES6 promises.\r\n            const deferred = new Deferred<boolean>();\r\n\r\n            const readAndUploadCycle = (_: boolean) => {\r\n                audioStreamNode.Read().On(\r\n                    (audioStreamChunk: IStreamChunk<ArrayBuffer>) => {\r\n                        // we have a new audio chunk to upload.\r\n                        if (requestSession.IsSpeechEnded) {\r\n                            // If service already recognized audio end then dont send any more audio\r\n                            deferred.Resolve(true);\r\n                            return;\r\n                        }\r\n\r\n                        const payload = (audioStreamChunk.IsEnd) ? null : audioStreamChunk.Buffer;\r\n                        const uploaded = connection.Send(\r\n                            new SpeechConnectionMessage(\r\n                                MessageType.Binary, \"audio\", requestId, null, payload));\r\n\r\n                        if (!audioStreamChunk.IsEnd) {\r\n                            uploaded.OnSuccessContinueWith(readAndUploadCycle);\r\n                        } else {\r\n                            // the audio stream has been closed, no need to schedule next\r\n                            // read-upload cycle.\r\n                            deferred.Resolve(true);\r\n                        }\r\n                    },\r\n                    (error: string) => {\r\n                        if (requestSession.IsSpeechEnded) {\r\n                            // For whatever reason, Reject is used to remove queue subscribers inside\r\n                            // the Queue.DrainAndDispose invoked from DetachAudioNode down blow, which\r\n                            // means that sometimes things can be rejected in normal circumstances, without\r\n                            // any errors.\r\n                            deferred.Resolve(true); // TODO: remove the argument, it's is completely meaningless.\r\n                        } else {\r\n                            // Only reject, if there was a proper error.\r\n                            deferred.Reject(error);\r\n                        }\r\n                    });\r\n            };\r\n\r\n            readAndUploadCycle(true);\r\n\r\n            return deferred.Promise();\r\n    }\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nclass RequestSession {\r\n    private isDisposed: boolean = false;\r\n    private serviceTelemetryListener: ServiceTelemetryListener;\r\n    private detachables: IDetachable[] = new Array<IDetachable>();\r\n    private requestId: string;\r\n    private audioSourceId: string;\r\n    private audioNodeId: string;\r\n    private audioNode: IAudioStreamNode;\r\n    private authFetchEventId: string;\r\n    private connectionId: string;\r\n    private serviceTag: string;\r\n    private isAudioNodeDetached: boolean = false;\r\n    private isCompleted: boolean = false;\r\n    private onEventCallback: (event: SpeechRecognitionEvent) => void;\r\n\r\n    private requestCompletionDeferral: Deferred<boolean>;\r\n\r\n    constructor(audioSourceId: string, onEventCallback: (event: SpeechRecognitionEvent) => void) {\r\n        this.audioSourceId = audioSourceId;\r\n        this.onEventCallback = onEventCallback;\r\n        this.requestId = CreateNoDashGuid();\r\n        this.audioNodeId = CreateNoDashGuid();\r\n        this.requestCompletionDeferral = new Deferred<boolean>();\r\n\r\n        this.serviceTelemetryListener = new ServiceTelemetryListener(this.requestId, this.audioSourceId, this.audioNodeId);\r\n\r\n        this.OnEvent(new RecognitionTriggeredEvent(this.RequestId, this.audioSourceId, this.audioNodeId));\r\n    }\r\n\r\n    public get RequestId(): string {\r\n        return this.requestId;\r\n    }\r\n\r\n    public get AudioNodeId(): string {\r\n        return this.audioNodeId;\r\n    }\r\n\r\n    public get CompletionPromise(): Promise<boolean> {\r\n        return this.requestCompletionDeferral.Promise();\r\n    }\r\n\r\n    public get IsSpeechEnded(): boolean {\r\n        return this.isAudioNodeDetached;\r\n    }\r\n\r\n    public get IsCompleted(): boolean {\r\n        return this.isCompleted;\r\n    }\r\n\r\n    public ListenForServiceTelemetry(eventSource: IEventSource<PlatformEvent>): void {\r\n        this.detachables.push(eventSource.AttachListener(this.serviceTelemetryListener));\r\n    }\r\n\r\n    public OnAudioSourceAttachCompleted = (audioNode: IAudioStreamNode, isError: boolean, error?: string): void => {\r\n        this.audioNode = audioNode;\r\n        if (isError) {\r\n            this.OnComplete(RecognitionCompletionStatus.AudioSourceError, error);\r\n        } else {\r\n            this.OnEvent(new ListeningStartedEvent(this.requestId, this.audioSourceId, this.audioNodeId));\r\n        }\r\n    }\r\n\r\n    public OnPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.authFetchEventId = authFetchEventId;\r\n        this.connectionId = connectionId;\r\n        this.OnEvent(new ConnectingToServiceEvent(this.requestId, this.authFetchEventId, this.connectionId));\r\n    }\r\n\r\n    public OnAuthCompleted = (isError: boolean, error?: string): void => {\r\n        if (isError) {\r\n            this.OnComplete(RecognitionCompletionStatus.AuthTokenFetchError, error);\r\n        }\r\n    }\r\n\r\n    public OnConnectionEstablishCompleted = (statusCode: number, reason?: string): void => {\r\n        if (statusCode === 200) {\r\n            this.OnEvent(new RecognitionStartedEvent(this.RequestId, this.audioSourceId, this.audioNodeId, this.authFetchEventId, this.connectionId));\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.OnComplete(RecognitionCompletionStatus.UnAuthorized, reason);\r\n        } else {\r\n            this.OnComplete(RecognitionCompletionStatus.ConnectError, reason);\r\n        }\r\n    }\r\n\r\n    public OnServiceTurnStartResponse = (response: ITurnStartResponse): void => {\r\n        if (response && response.context && response.context.serviceTag) {\r\n            this.serviceTag = response.context.serviceTag;\r\n        }\r\n    }\r\n\r\n    public OnServiceSpeechStartDetectedResponse = (result: ISpeechStartDetectedResult): void => {\r\n        this.OnEvent(new SpeechStartDetectedEvent(this.RequestId, result));\r\n    }\r\n\r\n    public OnServiceSpeechHypothesisResponse = (result: ISpeechFragment): void => {\r\n        this.OnEvent(new SpeechHypothesisEvent(this.RequestId, result));\r\n    }\r\n\r\n    public OnServiceSpeechFragmentResponse = (result: ISpeechFragment): void => {\r\n        this.OnEvent(new SpeechFragmentEvent(this.RequestId, result));\r\n    }\r\n\r\n    public OnServiceSpeechEndDetectedResponse = (result: ISpeechEndDetectedResult): void => {\r\n        this.DetachAudioNode();\r\n        this.OnEvent(new SpeechEndDetectedEvent(this.RequestId, result));\r\n    }\r\n\r\n    public OnServiceSimpleSpeechPhraseResponse = (result: ISimpleSpeechPhrase): void => {\r\n        this.OnEvent(new SpeechSimplePhraseEvent(this.RequestId, result));\r\n    }\r\n\r\n    public OnServiceDetailedSpeechPhraseResponse = (result: IDetailedSpeechPhrase): void => {\r\n        this.OnEvent(new SpeechDetailedPhraseEvent(this.RequestId, result));\r\n    }\r\n\r\n    public OnServiceTurnEndResponse = (): void => {\r\n        this.OnComplete(RecognitionCompletionStatus.Success);\r\n    }\r\n\r\n    public OnConnectionError = (error: string): void => {\r\n        this.OnComplete(RecognitionCompletionStatus.UnknownError, error);\r\n    }\r\n\r\n    public Dispose = (error?: string): void => {\r\n        if (!this.isDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.OnComplete(RecognitionCompletionStatus.UnknownError, error);\r\n            this.isDisposed = true;\r\n            for (const detachable of this.detachables) {\r\n                detachable.Detach();\r\n            }\r\n\r\n            this.serviceTelemetryListener.Dispose();\r\n        }\r\n    }\r\n\r\n    public GetTelemetry = (): string => {\r\n        return this.serviceTelemetryListener.GetTelemetry();\r\n    }\r\n\r\n    private OnComplete = (status: RecognitionCompletionStatus, error?: string): void => {\r\n        if (!this.isCompleted) {\r\n            this.isCompleted = true;\r\n            this.DetachAudioNode();\r\n            this.OnEvent(new RecognitionEndedEvent(this.RequestId, this.audioSourceId, this.audioNodeId, this.authFetchEventId, this.connectionId, this.serviceTag, status, error ? error : \"\"));\r\n        }\r\n    }\r\n\r\n    private DetachAudioNode = (): void => {\r\n        if (!this.isAudioNodeDetached) {\r\n            this.isAudioNodeDetached = true;\r\n            if (this.audioNode) {\r\n                this.audioNode.Detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private OnEvent = (event: SpeechRecognitionEvent): void => {\r\n        this.serviceTelemetryListener.OnEvent(event);\r\n        Events.Instance.OnEvent(event);\r\n        if (this.onEventCallback) {\r\n            this.onEventCallback(event);\r\n        }\r\n    }\r\n}\r\n\r\ninterface ITurnStartResponse {\r\n    context: ITurnStartContext;\r\n}\r\n\r\ninterface ITurnStartContext {\r\n    serviceTag: string;\r\n}\r\n"]}